!function(i,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((i="undefined"!=typeof globalThis?globalThis:i||self).AngryPixel2dPhysics={})}(this,(function(i){"use strict";class t{constructor(i=0,t=0){this._x=i,this._y=t}get x(){return this._x}set x(i){this._x=i}get y(){return this._y}set y(i){this._y=i}get magnitude(){return Math.sqrt(Math.pow(this._x,2)+Math.pow(this._y,2))}set(i,t){this._x=i,this._y=t}copy(i){this.set(i.x,i.y)}equals(i){return this._x===i.x&&this._y===i.y}clone(){return new t(this._x,this._y)}distance(i){return Math.sqrt(Math.pow(this._x-i.x,2)+Math.pow(this._y-i.y,2))}static add(i,t,e){return i.set(t.x+e.x,t.y+e.y),i}static subtract(i,t,e){return i.set(t.x-e.x,t.y-e.y),i}static unit(i,t){return 0===t.magnitude?i.set(0,0):i.set(t.x/t.magnitude,t.y/t.magnitude),i}static normal(i,t){return i.set(-t.y,t.x),this.unit(i,i)}static scale(i,t,e){return i.set(t.x*e,t.y*e),i}static dot(i,t){return i.x*t.x+i.y*t.y}static cross(i,t){return i.x*t.y-i.y*t.x}static round(i,t){return i.set(Math.round(t.x),Math.round(t.y)),i}}class e{constructor(i,e,s,o){this._position=new t,this._center=new t,this._width=0,this._height=0,this.set(i,e,s,o)}get x(){return this._position.x}set x(i){this._position.set(i,this._position.y)}get y(){return this._position.y}set y(i){this._position.set(this._position.x,i)}get x1(){return this._position.x+this._width}get y1(){return this._position.y+this._height}get position(){return this._position}set position(i){this._position.set(i.x,i.y)}get width(){return this._width}set width(i){this._width=i}get height(){return this._height}set height(i){this._height=i}get center(){return this._center.set(this.x+this.width/2,this.y+this.height/2),this._center}set(i,t,e,s){this._position.set(i,t),this._width=e,this._height=s}equals(i){return this.position.equals(i.position)&&this.width===i.width&&this.height===i.height}copy(i){this.set(i.x,i.y,i.width,i.height)}overlaps(i){return this.x1>=i.x&&this.x<i.x1&&this.y1>=i.y&&this.y<i.y1}contains(i){return i instanceof e?i.x1<=this.x1&&i.x>=this.x&&i.y1<=this.y1&&i.y>=this.y:i instanceof t&&!(i.x<this.x||i.y<this.y||i.x>=this.x1||i.y>=this.y1)}}const s=(i,t,e)=>Math.min(e,Math.max(t,i));class o{constructor(){this.lastId=0}create({shape:i,layer:e,updateCollisions:s,physics:o,position:r,rotation:n,group:h,onCollision:a}){return{id:++this.lastId,active:!0,layer:e,shape:i,updateCollisions:s,physics:o,position:null!=r?r:new t,rotation:null!=n?n:0,group:h,onCollision:a}}}class r{constructor(i,t=0){this.childrenArea=[],this.children=[],this.items=[],this.depth=t,this.resize(i)}resize(i){this.clear(),this.area=i;const t=i.width/2,s=i.height/2;this.childrenArea=[new e(this.area.x,this.area.y+s,t,s),new e(this.area.x+t,this.area.y+s,t,s),new e(this.area.x,this.area.y,t,s),new e(this.area.x+t,this.area.y,t,s)]}clear(){this.items=[];for(let i=0;i<4;i++)this.children[i]&&this.children[i].clear(),delete this.children[i]}insert(i,t){for(let e=0;e<4;e++)if(this.childrenArea[e].contains(t)&&this.depth+1<8)return this.children[e]||(this.children[e]=new r(this.childrenArea[e],this.depth+1)),this.children[e].insert(i,t);this.items.push([t,i])}retrieve(i,t=[]){return this.area.overlaps(i)&&(this.items.forEach((i=>t.push(i[1]))),this.children.forEach((e=>e.retrieve(i,t)))),t}}class n{constructor(i,s,o){this.collisions=[],this.minArea=new t,this.maxArea=new t,this.newArea=new e(0,0,0,0),this.method=i,this.colliders=[],this.activeColliders=[],this.collisionMatrix=o,this.setupQuadTree(s)}setupQuadTree(i){this.quadTreeArea=null!=i?i:new e(0,0,0,0),this.fixedQuadTree=!!i,this.quadTree=new r(this.quadTreeArea)}addCollider(i){this.colliders[i.id]=i}getCollider(i){return this.colliders[i]}removeCollider(i){delete this.colliders[i.id]}clearColliders(){this.colliders=[]}getCollisionsForCollider(i){return i.active?this.collisions.filter((t=>t.localCollider.id===i.id)):[]}refreshCollisionsForCollider(i){this.colliders[i.id]&&i.active&&(this.collisions=this.collisions.filter((t=>t.localCollider.id!==i.id&&t.remoteCollider.id!==i.id)),this.updateShape(i),this.narrowPhase(i,this.broadPhase(i)))}resolve(){this.collisions=[],0!==this.colliders.length&&(this.activeColliders=this.colliders.filter((i=>i.active)),this.quadTree.clear(),this.activeColliders.forEach((i=>{this.updateShape(i)})),!1===this.fixedQuadTree&&(this.updateNewArea(),!1===this.newArea.equals(this.quadTreeArea)&&(this.quadTreeArea.copy(this.newArea),this.quadTree.resize(this.quadTreeArea))),this.activeColliders.forEach((({id:i,shape:{boundingBox:t}})=>this.quadTree.insert(i,t))),this.updateCollisions())}updateShape(i){i.shape.position=i.position,i.shape.rotation=i.rotation,i.shape.update()}updateNewArea(){this.activeColliders.forEach((({shape:{boundingBox:i}})=>{this.minArea.set(Math.min(i.x,this.minArea.x),Math.min(i.y,this.minArea.y)),this.maxArea.set(Math.max(i.x1,this.maxArea.x),Math.max(i.y1,this.maxArea.y))})),this.newArea.set(this.minArea.x,this.minArea.y,this.maxArea.x-this.minArea.x,this.maxArea.y-this.minArea.y)}updateCollisions(){this.activeColliders.filter((i=>i.updateCollisions)).forEach((i=>this.narrowPhase(i,this.broadPhase(i))))}broadPhase(i){return this.collisionMatrix?this.quadTree.retrieve(i.shape.boundingBox).map((i=>this.colliders[i])).filter((t=>this.collisionMatrix.some((e=>e[0]===i.layer&&e[1]===t.layer||e[1]===i.layer&&e[0]===t.layer)))):this.quadTree.retrieve(i.shape.boundingBox).map((i=>this.colliders[i]))}narrowPhase(i,t){t.filter((t=>!(i.group&&t.group&&t.group===i.group||i.id===t.id))).forEach((t=>{if(this.isResolved(i,t))return;const e=this.method.getCollisionResolution(i.shape,t.shape);null!==e&&(this.collisions.push({localCollider:i,remoteCollider:t,resolution:e},{localCollider:t,remoteCollider:i,resolution:{direction:e.displacementDirection,displacementDirection:e.direction,penetration:e.penetration}}),i.onCollision&&i.onCollision(e))}))}isResolved(i,t){for(const e of this.collisions)if(e.localCollider.id===i.id&&e.remoteCollider.id===t.id)return!0;return!1}}var h,a,l;!function(i){i[i.Polygon=0]="Polygon",i[i.Circumference=1]="Circumference",i[i.Line=2]="Line"}(h||(h={}));class c{constructor(i,t,e){this.AABBResolver=i,this.circumferenceAABBResolver=t,this.circumferenceResolver=e}getCollisionResolution(i,t){return i.type===h.Polygon&&t.type===h.Polygon?this.AABBResolver.resolve(i,t):i.type===h.Circumference&&t.type===h.Polygon?this.circumferenceAABBResolver.resolve(i,t):i.type===h.Polygon&&t.type===h.Circumference?this.circumferenceAABBResolver.resolve(t,i,!0):i.type===h.Circumference&&t.type===h.Circumference?this.circumferenceResolver.resolve(i,t):null}}i.CollisionMethods=void 0,(a=i.CollisionMethods||(i.CollisionMethods={}))[a.AABB=0]="AABB",a[a.SAT=1]="SAT";class d{constructor(i,t){this.circumferenceResolver=i,this.satResolver=t}getCollisionResolution(i,t){return i.type===h.Circumference&&t.type===h.Circumference?this.circumferenceResolver.resolve(i,t):this.satResolver.resolve(i,t)}}class p{constructor(){this.direction=new t,this.displacementDirection=new t}resolve({boundingBox:i},{boundingBox:e}){return this.overlapX=Math.min(i.x1,e.x1)-Math.max(i.x,e.x),this.overlapY=Math.min(i.y1,e.y1)-Math.max(i.y,e.y),this.overlapX<0||this.overlapY<0?null:(this.direction.set(Math.sign(e.x1-i.x1),Math.sign(e.y1-i.y1)),this.preventContainment(i,e),this.overlapY<this.overlapX?(this.minOverlap=this.overlapY,this.displacementDirection.set(0,-this.direction.y)):(this.minOverlap=this.overlapX,this.displacementDirection.set(-this.direction.x,this.overlapY===this.overlapX?-this.direction.y:0)),t.unit(this.displacementDirection,this.displacementDirection),{direction:t.scale(new t,this.displacementDirection,-1),displacementDirection:this.displacementDirection.clone(),penetration:this.minOverlap})}preventContainment(i,t){if(this.overlapY>0&&(i.y1>t.y1&&i.y<t.y||i.y1<t.y1&&i.y>t.y)){const e=Math.abs(i.y-t.y),s=Math.abs(i.y1-t.y1);this.overlapY+=e<s?e:s,this.direction.y*=e<s?1:-1}if(this.overlapX>0&&(i.x1>t.x1&&i.x<t.x||i.x1<t.x1&&i.x>t.x)){const e=Math.abs(i.x-t.x),s=Math.abs(i.x1-t.x1);this.overlapX+=e<s?e:s,this.direction.x*=e<s?1:-1}}}class u{constructor(){this.closestPoint=new t,this.distance=new t,this.direction=new t}resolve(i,e,o=!1){return this.closestPoint.set(s(i.position.x,e.boundingBox.x,e.boundingBox.x1),s(i.position.y,e.boundingBox.y,e.boundingBox.y1)),t.subtract(this.distance,this.closestPoint,i.position),this.distance.magnitude>i.radius?null:(t.unit(this.direction,this.distance),{direction:o?t.scale(new t,this.direction,-1):this.direction.clone(),displacementDirection:o?this.direction.clone():t.scale(new t,this.direction,-1),penetration:i.radius-this.distance.magnitude})}}class x{constructor(){this.distance=new t,this.direction=new t}resolve(i,e){return t.subtract(this.distance,e.position,i.position),this.distance.magnitude>i.radius+e.radius?null:(t.unit(this.direction,this.distance),{direction:this.direction.clone(),displacementDirection:t.scale(new t,this.direction,-1),penetration:i.radius+e.radius-this.distance.magnitude})}}class y{constructor(){this.projA={min:0,max:0},this.projB={min:0,max:0},this.smallestAxis=new t,this.distance=new t(1/0,1/0),this.cache=new t}resolve(i,e){this.minOverlap=1/0,i.type===h.Circumference?this.setCircumferenceAxis(i,e):e.type===h.Circumference&&this.setCircumferenceAxis(e,i),this.axes=[...i.projectionAxes],e.projectionAxes.forEach((i=>this.axes.some((t=>t.equals(i)))?null:this.axes.push(i)));for(let s=0;s<this.axes.length;s++){if(i.type===h.Circumference?this.setCircumferenceVertices(i,this.axes[s]):e.type===h.Circumference&&this.setCircumferenceVertices(e,this.axes[s]),this.projectShapeOntoAxis(this.projA,i,this.axes[s]),this.projectShapeOntoAxis(this.projB,e,this.axes[s]),this.currentOverlap=Math.min(this.projA.max,this.projB.max)-Math.max(this.projA.min,this.projB.min),this.currentOverlap<0)return null;if(this.invertAxis=!0,this.projA.max>this.projB.max&&this.projA.min<this.projB.min||this.projA.max<this.projB.max&&this.projA.min>this.projB.min){const i=Math.abs(this.projA.min-this.projB.min),e=Math.abs(this.projA.max-this.projB.max);i<e?this.currentOverlap+=i:(this.currentOverlap+=e,t.scale(this.axes[s],this.axes[s],-1),this.invertAxis=!1)}this.currentOverlap<this.minOverlap&&(this.minOverlap=this.currentOverlap,this.smallestAxis.copy(this.axes[s]),this.invertAxis&&this.projA.max<this.projB.max&&t.scale(this.smallestAxis,this.axes[s],-1))}return{direction:t.scale(new t,this.smallestAxis,-1),displacementDirection:this.smallestAxis.clone(),penetration:this.minOverlap}}projectShapeOntoAxis(i,e,s){return i.min=1/0,i.max=-1/0,e.vertices.forEach((e=>{i.min=Math.min(t.dot(s,e),i.min),i.max=Math.max(t.dot(s,e),i.max)})),i}setCircumferenceAxis(i,e){this.distance.set(1/0,1/0),e.vertices.forEach((e=>{t.subtract(this.cache,e,i.position),this.cache.magnitude<this.distance.magnitude&&this.distance.copy(this.cache)})),t.unit(i.projectionAxes[0],this.distance)}setCircumferenceVertices(i,e){t.add(i.vertices[0],i.position,t.scale(this.cache,t.unit(this.cache,e),-i.radius)),t.add(i.vertices[1],i.position,t.scale(this.cache,t.unit(this.cache,e),i.radius))}}class m{constructor(i,t,e,s){this.collisionManager=i,this.colliderFactory=t,this.rigidBodyManager=e,this.rigidBodyFactory=s}addCollider(i){const t=this.colliderFactory.create(i);return this.collisionManager.addCollider(t),t}removeCollider(i){this.collisionManager.removeCollider(i)}getCollisionsForCollider(i){return this.collisionManager.getCollisionsForCollider(i)}addRigidBody(i){const t=this.rigidBodyFactory.create(i);return this.rigidBodyManager.addRigidBody(t),t}removeRigidBody(i){this.rigidBodyManager.removeRigidBody(i)}resolve(i){this.collisionManager.resolve(),this.rigidBodyManager.resolve(i)}clear(){this.collisionManager.clearColliders(),this.rigidBodyManager.clearRigidBodies()}}class v{constructor(){this.lastId=0}create({colliderIds:i,type:e,gravity:s,position:o,velocity:r,onResolve:n}){if(0===i.length)throw new Error("RigidBody needs at least one collider");return{id:++this.lastId,active:!0,colliderIds:i,type:e,gravity:null!=s?s:0,position:null!=o?o:new t,velocity:null!=r?r:new t,onResolve:n}}}i.RigidBodyType=void 0,(l=i.RigidBodyType||(i.RigidBodyType={}))[l.Static=0]="Static",l[l.Dynamic=1]="Dynamic",l[l.Kinematic=2]="Kinematic";const g=["x","y"];class M{constructor(i){this.collisionManager=i,this.rigidBodies=[],this.activeRigidBodies=[],this.colliders=[],this.velocity=new t,this.displacement=new t,this.cacheDisplacement=0}addRigidBody(i){this.rigidBodies[i.id]=i}removeRigidBody(i){delete this.rigidBodies[i.id]}clearRigidBodies(){this.rigidBodies=[]}resolve(t){this.activeRigidBodies=this.rigidBodies.filter((i=>i.active)),this.colliders=this.activeRigidBodies.reduce(((i,t)=>[...i,...t.colliderIds]),[]),this.activeRigidBodies.forEach((e=>{e.type===i.RigidBodyType.Dynamic?this.dynamicUpdate(e,t):e.type===i.RigidBodyType.Kinematic&&this.kinematicUpdate(e,t),e.onResolve&&e.onResolve(e)}))}dynamicUpdate(i,t){this.applyGravity(i,t),g.forEach((e=>{this.applyVelocity(i,t,e),this.obtainDisplacement(i,e),this.applyReposition(i,e)}))}kinematicUpdate(i,e){t.add(i.position,i.position,t.scale(this.velocity,i.velocity,e)),i.colliderIds.map((i=>this.collisionManager.getCollider(i))).forEach((i=>{t.add(i.position,i.position,this.velocity),this.collisionManager.refreshCollisionsForCollider(i)}))}applyGravity(i,t){i.gravity>0&&(i.velocity.y-=i.gravity*t)}applyVelocity(i,t,e){this.velocity[e]=i.velocity[e]*t,0!==this.velocity[e]&&(i.position[e]+=this.velocity[e],i.colliderIds.map((i=>this.collisionManager.getCollider(i))).forEach((i=>{i.position[e]+=this.velocity[e],this.collisionManager.refreshCollisionsForCollider(i)})))}obtainDisplacement(i,t){this.displacement[t]=0,this.getCollisions(i).forEach((i=>{this.cacheDisplacement=i.resolution.displacementDirection[t]*i.resolution.penetration,this.displacement[t]=Math.abs(this.displacement[t])>Math.abs(this.cacheDisplacement)?this.displacement[t]:this.cacheDisplacement}))}applyReposition(i,t){0!==this.displacement[t]&&(i.position[t]+=this.displacement[t],i.colliderIds.map((i=>this.collisionManager.getCollider(i))).forEach((i=>{i.position[t]+=this.displacement[t],this.collisionManager.refreshCollisionsForCollider(i)})),Math.sign(this.displacement[t])!==Math.sign(i.velocity[t])&&(i.velocity[t]=0))}getCollisions(i){return i.colliderIds.map((i=>this.collisionManager.getCollider(i))).filter((i=>i.active&&i.physics)).reduce(((i,t)=>(i.push(...this.collisionManager.getCollisionsForCollider(t).filter((i=>i.remoteCollider.physics&&this.colliders.includes(i.remoteCollider.id)))),i)),[])}}class A{constructor(i){this.vertexModel=i,this.type=h.Polygon,this.vertices=[],this.boundingBox=new e(0,0,0,0),this.rotation=0,this._projectionAxes=[],this._position=new t,this.boxMinX=Number.MAX_SAFE_INTEGER,this.boxMinY=Number.MAX_SAFE_INTEGER,this.boxMaxX=-Number.MAX_SAFE_INTEGER,this.boxMaxY=-Number.MAX_SAFE_INTEGER;for(let i=0;i<this.vertexModel.length;i++)this.vertices.push(new t),this._projectionAxes.push(new t)}set position(i){this._position.copy(i)}get position(){return this._position}get projectionAxes(){return this._projectionAxes}update(){this.updateVertices(),this.updateBoundingBox(),this.updateProjectionAxes()}updateVertices(){for(let i=0;i<this.vertexModel.length;i++)this.vertices[i].set(this.vertexModel[i].x*Math.cos(this.rotation)-this.vertexModel[i].y*Math.sin(this.rotation)+this._position.x,this.vertexModel[i].x*Math.sin(this.rotation)+this.vertexModel[i].y*Math.cos(this.rotation)+this._position.y)}updateBoundingBox(){this.boxMinX=this.vertices[0].x,this.boxMinY=this.vertices[0].y,this.boxMaxX=this.vertices[0].x,this.boxMaxY=this.vertices[0].y,this.vertices.forEach((i=>{this.boxMinX=Math.min(i.x,this.boxMinX),this.boxMinY=Math.min(i.y,this.boxMinY),this.boxMaxX=Math.max(i.x,this.boxMaxX),this.boxMaxY=Math.max(i.y,this.boxMaxY)})),this.boundingBox.set(this.boxMinX,this.boxMinY,this.boxMaxX-this.boxMinX,this.boxMaxY-this.boxMinY)}updateProjectionAxes(){var i;for(let e=0;e<this.vertices.length;e++)t.normal(this._projectionAxes[e],t.subtract(this._projectionAxes[e],null!==(i=this.vertices[e+1])&&void 0!==i?i:this.vertices[0],this.vertices[e]))}}i.Circumference=class{constructor(i){this.radius=i,this.type=h.Circumference,this.boundingBox=new e(0,0,0,0),this.vertices=[new t,new t],this.projectionAxes=[new t],this._position=new t}set position(i){this._position.copy(i)}get position(){return this._position}update(){this.updateBoundingBox()}updateBoundingBox(){this.boundingBox.set(this.position.x-this.radius,this.position.y-this.radius,2*this.radius,2*this.radius)}},i.Line=class{constructor(i){this.vertexModel=i,this.type=h.Polygon,this.vertices=[new t,new t],this.projectionAxes=[new t],this.boundingBox=new e(0,0,0,0),this.rotation=0,this._position=new t}update(){this.updateVertices(),this.updateBoundingBox(),this.updateProjectionAxes()}set position(i){this._position.copy(i)}get position(){return this._position}updateVertices(){for(let i=0;i<this.vertexModel.length;i++)this.vertices[i].set(this.vertexModel[i].x*Math.cos(this.rotation)-this.vertexModel[i].y*Math.sin(this.rotation)+this._position.x,this.vertexModel[i].x*Math.sin(this.rotation)+this.vertexModel[i].y*Math.cos(this.rotation)+this._position.y)}updateBoundingBox(){this.boundingBox.x=Math.min(this.vertices[0].x,this.vertices[1].x),this.boundingBox.y=Math.min(this.vertices[0].y,this.vertices[1].y),this.boundingBox.width=Math.max(this.vertices[0].x,this.vertices[1].x)-this.boundingBox.x,this.boundingBox.height=Math.max(this.vertices[0].y,this.vertices[1].y)-this.boundingBox.y}updateProjectionAxes(){t.normal(this.projectionAxes[0],t.subtract(this.projectionAxes[0],this.vertices[1],this.vertices[0]))}},i.Polygon=A,i.Rectangle=class extends A{constructor(i,e){super([new t(-i/2,-e/2),new t(-i/2,e/2),new t(i/2,e/2),new t(i/2,-e/2)]),this.width=i,this.height=e,this._projectionAxes=[new t,new t]}updateSize(i,t){this.width=i,this.height=t,this.vertexModel[0].set(-i/2,-t/2),this.vertexModel[1].set(-i/2,t/2),this.vertexModel[2].set(i/2,t/2),this.vertexModel[3].set(i/2,-t/2)}updateProjectionAxes(){t.unit(this.projectionAxes[0],t.subtract(this.projectionAxes[0],this.vertices[1],this.vertices[0])),t.normal(this.projectionAxes[1],this.projectionAxes[0])}},i.physicsManagerFactory=({collisionArea:t,collisionMatrix:e,collisionMethod:s}={})=>{const r=new x,h=s===i.CollisionMethods.AABB?new c(new p,new u,r):new d(r,new y),a=new n(h,t,e),l=new o,g=new M(a),A=new v;return new m(a,l,g,A)},Object.defineProperty(i,"__esModule",{value:!0})}));
