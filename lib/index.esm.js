class i{constructor(i=0,t=0){this._x=i,this._y=t}get x(){return this._x}set x(i){this._x=i}get y(){return this._y}set y(i){this._y=i}get magnitude(){return Math.sqrt(Math.pow(this._x,2)+Math.pow(this._y,2))}set(i,t){this._x=i,this._y=t}copy(i){this.set(i.x,i.y)}equals(i){return this._x===i.x&&this._y===i.y}clone(){return new i(this._x,this._y)}distance(i){return Math.sqrt(Math.pow(this._x-i.x,2)+Math.pow(this._y-i.y,2))}static add(i,t,e){return i.set(t.x+e.x,t.y+e.y),i}static subtract(i,t,e){return i.set(t.x-e.x,t.y-e.y),i}static unit(i,t){return 0===t.magnitude?i.set(0,0):i.set(t.x/t.magnitude,t.y/t.magnitude),i}static normal(i,t){return i.set(-t.y,t.x),this.unit(i,i)}static scale(i,t,e){return i.set(t.x*e,t.y*e),i}static dot(i,t){return i.x*t.x+i.y*t.y}static cross(i,t){return i.x*t.y-i.y*t.x}static round(i,t){return i.set(Math.round(t.x),Math.round(t.y)),i}}class t{constructor(t,e,s,o){this._position=new i,this._center=new i,this._width=0,this._height=0,this.set(t,e,s,o)}get x(){return this._position.x}set x(i){this._position.set(i,this._position.y)}get y(){return this._position.y}set y(i){this._position.set(this._position.x,i)}get x1(){return this._position.x+this._width}get y1(){return this._position.y+this._height}get position(){return this._position}set position(i){this._position.set(i.x,i.y)}get width(){return this._width}set width(i){this._width=i}get height(){return this._height}set height(i){this._height=i}get center(){return this._center.set(this.x+this.width/2,this.y+this.height/2),this._center}set(i,t,e,s){this._position.set(i,t),this._width=e,this._height=s}equals(i){return this.position.equals(i.position)&&this.width===i.width&&this.height===i.height}copy(i){this.set(i.x,i.y,i.width,i.height)}overlaps(i){return this.x1>=i.x&&this.x<i.x1&&this.y1>=i.y&&this.y<i.y1}contains(e){return e instanceof t?e.x1<=this.x1&&e.x>=this.x&&e.y1<=this.y1&&e.y>=this.y:e instanceof i&&!(e.x<this.x||e.y<this.y||e.x>=this.x1||e.y>=this.y1)}}const e=(i,t,e)=>Math.min(e,Math.max(t,i));class s{constructor(){this.lastId=0}create({shape:t,layer:e,updateCollisions:s,physics:o,position:r,rotation:n,group:h,onCollision:a}){return{id:++this.lastId,active:!0,layer:e,shape:t,updateCollisions:s,physics:o,position:null!=r?r:new i,rotation:null!=n?n:0,group:h,onCollision:a}}}class o{constructor(i,t=0){this.childrenArea=[],this.children=[],this.items=[],this.depth=t,this.resize(i)}resize(i){this.clear(),this.area=i;const e=i.width/2,s=i.height/2;this.childrenArea=[new t(this.area.x,this.area.y+s,e,s),new t(this.area.x+e,this.area.y+s,e,s),new t(this.area.x,this.area.y,e,s),new t(this.area.x+e,this.area.y,e,s)]}clear(){this.items=[];for(let i=0;i<4;i++)this.children[i]&&this.children[i].clear(),delete this.children[i]}insert(i,t){for(let e=0;e<4;e++)if(this.childrenArea[e].contains(t)&&this.depth+1<8)return this.children[e]||(this.children[e]=new o(this.childrenArea[e],this.depth+1)),this.children[e].insert(i,t);this.items.push([t,i])}retrieve(i,t=[]){return this.area.overlaps(i)&&(this.items.forEach((i=>t.push(i[1]))),this.children.forEach((e=>e.retrieve(i,t)))),t}}class r{constructor(e,s,o){this.collisions=[],this.minArea=new i,this.maxArea=new i,this.newArea=new t(0,0,0,0),this.method=e,this.colliders=[],this.activeColliders=[],this.collisionMatrix=o,this.setupQuadTree(s)}setupQuadTree(i){this.quadTreeArea=null!=i?i:new t(0,0,0,0),this.fixedQuadTree=!!i,this.quadTree=new o(this.quadTreeArea)}addCollider(i){this.colliders[i.id]=i}getCollider(i){return this.colliders[i]}removeCollider(i){delete this.colliders[i.id]}clearColliders(){this.colliders=[]}getCollisionsForCollider(i){return i.active?this.collisions.filter((t=>t.localCollider.id===i.id)):[]}refreshCollisionsForCollider(i){this.colliders[i.id]&&i.active&&(this.collisions=this.collisions.filter((t=>t.localCollider.id!==i.id&&t.remoteCollider.id!==i.id)),this.updateShape(i),this.narrowPhase(i,this.broadPhase(i)))}resolve(){this.collisions=[],0!==this.colliders.length&&(this.activeColliders=this.colliders.filter((i=>i.active)),this.quadTree.clear(),this.activeColliders.forEach((i=>{this.updateShape(i)})),!1===this.fixedQuadTree&&(this.updateNewArea(),!1===this.newArea.equals(this.quadTreeArea)&&(this.quadTreeArea.copy(this.newArea),this.quadTree.resize(this.quadTreeArea))),this.activeColliders.forEach((({id:i,shape:{boundingBox:t}})=>this.quadTree.insert(i,t))),this.updateCollisions())}updateShape(i){i.shape.position=i.position,i.shape.rotation=i.rotation,i.shape.update()}updateNewArea(){this.activeColliders.forEach((({shape:{boundingBox:i}})=>{this.minArea.set(Math.min(i.x,this.minArea.x),Math.min(i.y,this.minArea.y)),this.maxArea.set(Math.max(i.x1,this.maxArea.x),Math.max(i.y1,this.maxArea.y))})),this.newArea.set(this.minArea.x,this.minArea.y,this.maxArea.x-this.minArea.x,this.maxArea.y-this.minArea.y)}updateCollisions(){this.activeColliders.filter((i=>i.updateCollisions)).forEach((i=>this.narrowPhase(i,this.broadPhase(i))))}broadPhase(i){return this.collisionMatrix?this.quadTree.retrieve(i.shape.boundingBox).map((i=>this.colliders[i])).filter((t=>this.collisionMatrix.some((e=>e[0]===i.layer&&e[1]===t.layer||e[1]===i.layer&&e[0]===t.layer)))):this.quadTree.retrieve(i.shape.boundingBox).map((i=>this.colliders[i]))}narrowPhase(i,t){t.filter((t=>!(i.group&&t.group&&t.group===i.group||i.id===t.id))).forEach((t=>{if(this.isResolved(i,t))return;const e=this.method.getCollisionResolution(i.shape,t.shape);null!==e&&(this.collisions.push({localCollider:i,remoteCollider:t,resolution:e},{localCollider:t,remoteCollider:i,resolution:{direction:e.displacementDirection,displacementDirection:e.direction,penetration:e.penetration}}),i.onCollision&&i.onCollision(e))}))}isResolved(i,t){for(const e of this.collisions)if(e.localCollider.id===i.id&&e.remoteCollider.id===t.id)return!0;return!1}}var n,h,a;!function(i){i[i.Polygon=0]="Polygon",i[i.Circumference=1]="Circumference",i[i.Line=2]="Line"}(n||(n={}));class l{constructor(i,t,e){this.AABBResolver=i,this.circumferenceAABBResolver=t,this.circumferenceResolver=e}getCollisionResolution(i,t){return i.type===n.Polygon&&t.type===n.Polygon?this.AABBResolver.resolve(i,t):i.type===n.Circumference&&t.type===n.Polygon?this.circumferenceAABBResolver.resolve(i,t):i.type===n.Polygon&&t.type===n.Circumference?this.circumferenceAABBResolver.resolve(t,i,!0):i.type===n.Circumference&&t.type===n.Circumference?this.circumferenceResolver.resolve(i,t):null}}!function(i){i[i.AABB=0]="AABB",i[i.SAT=1]="SAT"}(h||(h={}));class c{constructor(i,t){this.circumferenceResolver=i,this.satResolver=t}getCollisionResolution(i,t){return i.type===n.Circumference&&t.type===n.Circumference?this.circumferenceResolver.resolve(i,t):this.satResolver.resolve(i,t)}}class d{constructor(){this.direction=new i,this.displacementDirection=new i}resolve({boundingBox:t},{boundingBox:e}){return this.overlapX=Math.min(t.x1,e.x1)-Math.max(t.x,e.x),this.overlapY=Math.min(t.y1,e.y1)-Math.max(t.y,e.y),this.overlapX<0||this.overlapY<0?null:(this.direction.set(Math.sign(e.x1-t.x1),Math.sign(e.y1-t.y1)),this.preventContainment(t,e),this.overlapY<this.overlapX?(this.minOverlap=this.overlapY,this.displacementDirection.set(0,-this.direction.y)):(this.minOverlap=this.overlapX,this.displacementDirection.set(-this.direction.x,this.overlapY===this.overlapX?-this.direction.y:0)),i.unit(this.displacementDirection,this.displacementDirection),{direction:i.scale(new i,this.displacementDirection,-1),displacementDirection:this.displacementDirection.clone(),penetration:this.minOverlap})}preventContainment(i,t){if(this.overlapY>0&&(i.y1>t.y1&&i.y<t.y||i.y1<t.y1&&i.y>t.y)){const e=Math.abs(i.y-t.y),s=Math.abs(i.y1-t.y1);this.overlapY+=e<s?e:s,this.direction.y*=e<s?1:-1}if(this.overlapX>0&&(i.x1>t.x1&&i.x<t.x||i.x1<t.x1&&i.x>t.x)){const e=Math.abs(i.x-t.x),s=Math.abs(i.x1-t.x1);this.overlapX+=e<s?e:s,this.direction.x*=e<s?1:-1}}}class p{constructor(){this.closestPoint=new i,this.distance=new i,this.direction=new i}resolve(t,s,o=!1){return this.closestPoint.set(e(t.position.x,s.boundingBox.x,s.boundingBox.x1),e(t.position.y,s.boundingBox.y,s.boundingBox.y1)),i.subtract(this.distance,this.closestPoint,t.position),this.distance.magnitude>t.radius?null:(i.unit(this.direction,this.distance),{direction:o?i.scale(new i,this.direction,-1):this.direction.clone(),displacementDirection:o?this.direction.clone():i.scale(new i,this.direction,-1),penetration:t.radius-this.distance.magnitude})}}class u{constructor(){this.distance=new i,this.direction=new i}resolve(t,e){return i.subtract(this.distance,e.position,t.position),this.distance.magnitude>t.radius+e.radius?null:(i.unit(this.direction,this.distance),{direction:this.direction.clone(),displacementDirection:i.scale(new i,this.direction,-1),penetration:t.radius+e.radius-this.distance.magnitude})}}class x{constructor(){this.projA={min:0,max:0},this.projB={min:0,max:0},this.smallestAxis=new i,this.distance=new i(1/0,1/0),this.cache=new i}resolve(t,e){this.minOverlap=1/0,t.type===n.Circumference?this.setCircumferenceAxis(t,e):e.type===n.Circumference&&this.setCircumferenceAxis(e,t),this.axes=[...t.projectionAxes],e.projectionAxes.forEach((i=>this.axes.some((t=>t.equals(i)))?null:this.axes.push(i)));for(let s=0;s<this.axes.length;s++){if(t.type===n.Circumference?this.setCircumferenceVertices(t,this.axes[s]):e.type===n.Circumference&&this.setCircumferenceVertices(e,this.axes[s]),this.projectShapeOntoAxis(this.projA,t,this.axes[s]),this.projectShapeOntoAxis(this.projB,e,this.axes[s]),this.currentOverlap=Math.min(this.projA.max,this.projB.max)-Math.max(this.projA.min,this.projB.min),this.currentOverlap<0)return null;if(this.invertAxis=!0,this.projA.max>this.projB.max&&this.projA.min<this.projB.min||this.projA.max<this.projB.max&&this.projA.min>this.projB.min){const t=Math.abs(this.projA.min-this.projB.min),e=Math.abs(this.projA.max-this.projB.max);t<e?this.currentOverlap+=t:(this.currentOverlap+=e,i.scale(this.axes[s],this.axes[s],-1),this.invertAxis=!1)}this.currentOverlap<this.minOverlap&&(this.minOverlap=this.currentOverlap,this.smallestAxis.copy(this.axes[s]),this.invertAxis&&this.projA.max<this.projB.max&&i.scale(this.smallestAxis,this.axes[s],-1))}return{direction:i.scale(new i,this.smallestAxis,-1),displacementDirection:this.smallestAxis.clone(),penetration:this.minOverlap}}projectShapeOntoAxis(t,e,s){return t.min=1/0,t.max=-1/0,e.vertices.forEach((e=>{t.min=Math.min(i.dot(s,e),t.min),t.max=Math.max(i.dot(s,e),t.max)})),t}setCircumferenceAxis(t,e){this.distance.set(1/0,1/0),e.vertices.forEach((e=>{i.subtract(this.cache,e,t.position),this.cache.magnitude<this.distance.magnitude&&this.distance.copy(this.cache)})),i.unit(t.projectionAxes[0],this.distance)}setCircumferenceVertices(t,e){i.add(t.vertices[0],t.position,i.scale(this.cache,i.unit(this.cache,e),-t.radius)),i.add(t.vertices[1],t.position,i.scale(this.cache,i.unit(this.cache,e),t.radius))}}class y{constructor(i,t,e,s){this.collisionManager=i,this.colliderFactory=t,this.rigidBodyManager=e,this.rigidBodyFactory=s}addCollider(i){const t=this.colliderFactory.create(i);return this.collisionManager.addCollider(t),t}removeCollider(i){this.collisionManager.removeCollider(i)}getCollisionsForCollider(i){return this.collisionManager.getCollisionsForCollider(i)}addRigidBody(i){const t=this.rigidBodyFactory.create(i);return this.rigidBodyManager.addRigidBody(t),t}removeRigidBody(i){this.rigidBodyManager.removeRigidBody(i)}resolve(i){this.collisionManager.resolve(),this.rigidBodyManager.resolve(i)}clear(){this.collisionManager.clearColliders(),this.rigidBodyManager.clearRigidBodies()}}class m{constructor(){this.lastId=0}create({colliderIds:t,type:e,gravity:s,position:o,velocity:r}){if(0===t.length)throw new Error("RigidBody needs at least one collider");return{id:++this.lastId,colliderIds:t,type:e,gravity:null!=s?s:0,position:null!=o?o:new i,velocity:null!=r?r:new i}}}!function(i){i[i.Static=0]="Static",i[i.Dynamic=1]="Dynamic",i[i.Kinematic=2]="Kinematic"}(a||(a={}));const v=["x","y"];class g{constructor(t){this.collisionManager=t,this.rigidBodies=[],this.colliders=[],this.velocity=new i,this.displacement=new i,this.cacheDisplacement=0}addRigidBody(i){this.rigidBodies[i.id]=i}removeRigidBody(i){delete this.rigidBodies[i.id]}clearRigidBodies(){this.rigidBodies=[]}resolve(i){this.colliders=this.rigidBodies.reduce(((i,t)=>[...i,...t.colliderIds]),[]),this.rigidBodies.forEach((t=>{t.type===a.Dynamic?this.dynamicUpdate(t,i):t.type===a.Kinematic&&this.kinematicUpdate(t,i),t.onResolve&&t.onResolve(t)}))}dynamicUpdate(i,t){this.applyGravity(i,t),v.forEach((e=>{this.applyVelocity(i,t,e),this.obtainDisplacement(i,e),this.applyReposition(i,e)}))}kinematicUpdate(t,e){i.add(t.position,t.position,i.scale(this.velocity,t.velocity,e))}applyGravity(i,t){i.gravity>0&&(i.velocity.y-=i.gravity*t)}applyVelocity(i,t,e){this.velocity[e]=i.velocity[e]*t,0!==this.velocity[e]&&(i.position[e]+=this.velocity[e],i.colliderIds.map((i=>this.collisionManager.getCollider(i))).forEach((i=>{i.position[e]+=this.velocity[e],this.collisionManager.refreshCollisionsForCollider(i)})))}obtainDisplacement(i,t){this.displacement[t]=0,this.getCollisions(i).forEach((i=>{this.cacheDisplacement=i.resolution.displacementDirection[t]*i.resolution.penetration,this.displacement[t]=Math.abs(this.displacement[t])>Math.abs(this.cacheDisplacement)?this.displacement[t]:this.cacheDisplacement}))}applyReposition(i,t){0!==this.displacement[t]&&(i.position[t]+=this.displacement[t],i.colliderIds.map((i=>this.collisionManager.getCollider(i))).forEach((i=>{i.position[t]+=this.displacement[t],this.collisionManager.refreshCollisionsForCollider(i)})),Math.sign(this.displacement[t])!==Math.sign(i.velocity[t])&&(i.velocity[t]=0))}getCollisions(i){return i.colliderIds.map((i=>this.collisionManager.getCollider(i))).filter((i=>i.active&&i.physics)).reduce(((i,t)=>(i.push(...this.collisionManager.getCollisionsForCollider(t).filter((i=>i.remoteCollider.physics&&this.colliders.includes(i.remoteCollider.id)))),i)),[])}}class M{constructor(e){this.radius=e,this.type=n.Circumference,this.boundingBox=new t(0,0,0,0),this.vertices=[new i,new i],this.projectionAxes=[new i],this._position=new i}set position(i){this._position.copy(i)}get position(){return this._position}update(){this.updateBoundingBox()}updateBoundingBox(){this.boundingBox.set(this.position.x-this.radius,this.position.y-this.radius,2*this.radius,2*this.radius)}}class A{constructor(e){this.vertexModel=e,this.type=n.Polygon,this.vertices=[new i,new i],this.projectionAxes=[new i],this.boundingBox=new t(0,0,0,0),this.rotation=0,this._position=new i}update(){this.updateVertices(),this.updateBoundingBox(),this.updateProjectionAxes()}set position(i){this._position.copy(i)}get position(){return this._position}updateVertices(){for(let i=0;i<this.vertexModel.length;i++)this.vertices[i].set(this.vertexModel[i].x*Math.cos(this.rotation)-this.vertexModel[i].y*Math.sin(this.rotation)+this._position.x,this.vertexModel[i].x*Math.sin(this.rotation)+this.vertexModel[i].y*Math.cos(this.rotation)+this._position.y)}updateBoundingBox(){this.boundingBox.x=Math.min(this.vertices[0].x,this.vertices[1].x),this.boundingBox.y=Math.min(this.vertices[0].y,this.vertices[1].y),this.boundingBox.width=Math.max(this.vertices[0].x,this.vertices[1].x)-this.boundingBox.x,this.boundingBox.height=Math.max(this.vertices[0].y,this.vertices[1].y)-this.boundingBox.y}updateProjectionAxes(){i.normal(this.projectionAxes[0],i.subtract(this.projectionAxes[0],this.vertices[1],this.vertices[0]))}}class w{constructor(e){this.vertexModel=e,this.type=n.Polygon,this.vertices=[],this.boundingBox=new t(0,0,0,0),this.rotation=0,this._projectionAxes=[],this._position=new i,this.boxMinX=Number.MAX_SAFE_INTEGER,this.boxMinY=Number.MAX_SAFE_INTEGER,this.boxMaxX=-Number.MAX_SAFE_INTEGER,this.boxMaxY=-Number.MAX_SAFE_INTEGER;for(let t=0;t<this.vertexModel.length;t++)this.vertices.push(new i),this._projectionAxes.push(new i)}set position(i){this._position.copy(i)}get position(){return this._position}get projectionAxes(){return this._projectionAxes}update(){this.updateVertices(),this.updateBoundingBox(),this.updateProjectionAxes()}updateVertices(){for(let i=0;i<this.vertexModel.length;i++)this.vertices[i].set(this.vertexModel[i].x*Math.cos(this.rotation)-this.vertexModel[i].y*Math.sin(this.rotation)+this._position.x,this.vertexModel[i].x*Math.sin(this.rotation)+this.vertexModel[i].y*Math.cos(this.rotation)+this._position.y)}updateBoundingBox(){this.boxMinX=this.vertices[0].x,this.boxMinY=this.vertices[0].y,this.boxMaxX=this.vertices[0].x,this.boxMaxY=this.vertices[0].y,this.vertices.forEach((i=>{this.boxMinX=Math.min(i.x,this.boxMinX),this.boxMinY=Math.min(i.y,this.boxMinY),this.boxMaxX=Math.max(i.x,this.boxMaxX),this.boxMaxY=Math.max(i.y,this.boxMaxY)})),this.boundingBox.set(this.boxMinX,this.boxMinY,this.boxMaxX-this.boxMinX,this.boxMaxY-this.boxMinY)}updateProjectionAxes(){var t;for(let e=0;e<this.vertices.length;e++)i.normal(this._projectionAxes[e],i.subtract(this._projectionAxes[e],null!==(t=this.vertices[e+1])&&void 0!==t?t:this.vertices[0],this.vertices[e]))}}class B extends w{constructor(t,e){super([new i(-t/2,-e/2),new i(-t/2,e/2),new i(t/2,e/2),new i(t/2,-e/2)]),this.width=t,this.height=e,this._projectionAxes=[new i,new i]}updateSize(i,t){this.width=i,this.height=t,this.vertexModel[0].set(-i/2,-t/2),this.vertexModel[1].set(-i/2,t/2),this.vertexModel[2].set(i/2,t/2),this.vertexModel[3].set(i/2,-t/2)}updateProjectionAxes(){i.unit(this.projectionAxes[0],i.subtract(this.projectionAxes[0],this.vertices[1],this.vertices[0])),i.normal(this.projectionAxes[1],this.projectionAxes[0])}}const C=({collisionArea:i,collisionMatrix:t,collisionMethod:e}={})=>{const o=new u,n=e===h.AABB?new l(new d,new p,o):new c(o,new x),a=new r(n,i,t),v=new s,M=new g(a),A=new m;return new y(a,v,M,A)};export{M as Circumference,h as CollisionMethods,A as Line,w as Polygon,B as Rectangle,a as RigidBodyType,C as physicsManagerFactory};
